# RandomX

RandomX是一种工作量证明（PoW）算法，旨在缩小通用CPU和专用硬件之间的性能差距。该算法的核心是虚拟CPU的模拟。

#### 目录

1. [定义](#1-定义)
1. [算法描述](#2-算法描述)
1. [自定义函数](#3-自定义函数)
1. [虚拟机](#4-虚拟机)
1. [指令集](#5-指令集)
1. [SuperscalarHash](#6-superscalarhash)
1. [数据集](#7-数据集)


## 1. 定义

### 1.1 一般定义

**Hash256** 和 **Hash512** 指的是[Blake2b](https://blake2.net/blake2_20130129.pdf)哈希函数，分别具有256位和512位输出大小。

**浮点格式** 指的是[IEEE-754双精度浮点格式](https://en.wikipedia.org/wiki/Double-precision_floating-point_format)，具有符号位、11位指数和52位尾数。

**Argon2d** 是[Argon2](https://github.com/P-H-C/phc-winner-argon2/blob/master/argon2-specs.pdf)的抗权衡变体，这是一种内存硬化的密码派生函数。

**AesGenerator1R** 指的是第3.2章中描述的基于AES的伪随机数生成器。它用512位种子值初始化，能够每时钟周期产生超过10字节的输出。

**AesGenerator4R** 是第3.3章中描述的较慢但更安全的基于AES的伪随机数生成器。它用512位种子值初始化。

**AesHash1R** 指的是第3.4章中描述的基于AES的指纹函数。它能够每时钟周期处理超过10字节，并产生512位输出。

**BlakeGenerator** 指的是第3.5章中描述的自定义伪随机数生成器。它基于Blake2b哈希函数。

**SuperscalarHash** 指的是为在超标量CPU上高效运行而设计的自定义扩散函数（见第7章）。它将64字节输入值转换为64字节输出值。

**虚拟机** 或 **VM** 指的是第4章中描述的RandomX虚拟机。

**编程VM** 指的是将程序和配置加载到VM中的行为。这在第4.5章中描述。

**执行VM** 指的是运行第4.6章中描述的程序循环的行为。

**暂存器** 指的是VM的工作空间内存。整个暂存器分为3个级别：L3 -> L2 -> L1，每个较低级别都是较高级别的子集。

**寄存器文件** 指的是通过按小端格式连接VM寄存器形成的256字节序列，顺序如下：`r0`-`r7`、`f0`-`f3`、`e0`-`e3`和`a0`-`a3`。

**程序缓冲区** 指的是VM从中读取指令的缓冲区。

**缓存** 指的是第7.1章中描述的由Argon2d初始化的只读缓冲区。

**数据集** 指的是第7章中描述的大型只读缓冲区。它是使用SuperscalarHash函数从缓存构造的。

### 1.2 可配置参数
RandomX有几个可配置参数，如表1.2.1所示，包含其默认值。

*表1.2.1 - 可配置参数*

|参数|描述|默认值|
|---------|-----|-------|
|`RANDOMX_ARGON_MEMORY`|缓存中1 KiB Argon2块的数量| `262144`|
|`RANDOMX_ARGON_ITERATIONS`|缓存初始化的Argon2d迭代次数|`3`|
|`RANDOMX_ARGON_LANES`|缓存初始化的并行通道数|`1`|
|`RANDOMX_ARGON_SALT`|Argon2盐值|`"RandomX\x03"`|
|`RANDOMX_CACHE_ACCESSES`|每个数据集项的随机缓存访问次数|`8`|
|`RANDOMX_SUPERSCALAR_LATENCY`|SuperscalarHash的目标延迟（参考CPU周期）|`170`|
|`RANDOMX_DATASET_BASE_SIZE`|数据集基础大小（字节）|`2147483648`|
|`RANDOMX_DATASET_EXTRA_SIZE`|数据集额外大小（字节）|`33554368`|
|`RANDOMX_PROGRAM_SIZE`|RandomX程序中的指令数量|`256`|
|`RANDOMX_PROGRAM_ITERATIONS`|每个程序的迭代次数|`2048`|
|`RANDOMX_PROGRAM_COUNT`|每个哈希的程序数量|`8`|
|`RANDOMX_JUMP_BITS`|跳转条件掩码大小（位）|`8`|
|`RANDOMX_JUMP_OFFSET`|跳转条件掩码偏移（位）|`8`|
|`RANDOMX_SCRATCHPAD_L3`|暂存器L3大小（字节）|`2097152`|
|`RANDOMX_SCRATCHPAD_L2`|暂存器L2大小（字节）|`262144`|
|`RANDOMX_SCRATCHPAD_L1`|暂存器L1大小（字节）|`16384`|

表5.2.1、5.3.1、5.4.1和5.5.1中列出的指令频率也是可配置的。

## 2. 算法描述

RandomX算法接受两个输入值：

* 大小为0-60字节的字符串`K`（密钥）
* 任意长度的字符串`H`（要哈希的值）

并输出256位结果`R`。

该算法由以下步骤组成：

1. 使用密钥值`K`初始化数据集（在第7章中描述）。
1. 计算64字节种子`S`为`S = Hash512(H)`。
1. 设`gen1 = AesGenerator1R(S)`。
1. 使用生成器`gen1`用`RANDOMX_SCRATCHPAD_L3`个随机字节填充暂存器。
1. 设`gen4 = AesGenerator4R(gen1.state)`（使用`gen1`的最终状态）。
1. VM寄存器`fprc`的值设置为0（默认舍入模式 - 第4.3章）。
1. 使用生成器`gen4`用`128 + 8 * RANDOMX_PROGRAM_SIZE`个随机字节编程VM（第4.5章）。
1. 执行VM（第4.6章）。
1. 计算新的64字节种子为`S = Hash512(RegisterFile)`。
1. 设置`gen4.state = S`（修改生成器的状态）。
1. 步骤7-10总共执行`RANDOMX_PROGRAM_COUNT`次。最后一次迭代跳过步骤9和10。
1. 计算暂存器指纹为`A = AesHash1R(Scratchpad)`。
1. 寄存器文件的字节192-255设置为`A`的值。
1. 计算结果为`R = Hash256(RegisterFile)`。

步骤9中`Hash512`函数的输入是以下256字节：
```
 +---------------------------------+
 |         寄存器 r0-r7            | (64字节)
 +---------------------------------+
 |         寄存器 f0-f3            | (64字节)
 +---------------------------------+
 |         寄存器 e0-e3            | (64字节)
 +---------------------------------+
 |         寄存器 a0-a3            | (64字节)
 +---------------------------------+
```

步骤14中`Hash256`函数的输入是以下256字节：
```
 +---------------------------------+
 |         寄存器 r0-r7            | (64字节)
 +---------------------------------+
 |         寄存器 f0-f3            | (64字节)
 +---------------------------------+
 |         寄存器 e0-e3            | (64字节)
 +---------------------------------+
 |      AesHash1R(暂存器)          | (64字节)
 +---------------------------------+
```

## 3. 自定义函数

### 3.1 定义

两个自定义函数基于[高级加密标准](https://en.wikipedia.org/wiki/Advanced_Encryption_Standard)（AES）。

**AES加密轮** 指的是应用ShiftRows、SubBytes和MixColumns变换，然后与轮密钥进行XOR。

**AES解密轮** 指的是应用逆ShiftRows、逆SubBytes和逆MixColumns变换，然后与轮密钥进行XOR。

### 3.2 AesGenerator1R

AesGenerator1R产生伪随机字节序列。

生成器的内部状态由64字节组成，排列成四列，每列16字节。在每次输出迭代期间，每列使用一轮AES进行解密（列0、2）或加密（列1、3），使用以下轮密钥（每列一个密钥）：

```
key0 = 53 a5 ac 6d 09 66 71 62 2b 55 b5 db 17 49 f4 b4
key1 = 07 af 7c 6d 0d 71 6a 84 78 d3 25 17 4e dc a1 0d
key2 = f1 62 12 3f c6 7e 94 9f 4f 79 c0 f4 45 e3 20 3e
key3 = 35 81 ef 6a 7c 31 ba b1 88 4c 31 16 54 91 16 49
```

这些密钥是通过以下方式生成的：
```
key0, key1, key2, key3 = Hash512("RandomX AesGenerator1R keys")
```

单次迭代产生64字节输出，这也成为生成器的新状态。
```
state0 (16 B)    state1 (16 B)    state2 (16 B)    state3 (16 B)
     |                |                |                |
 AES 解密         AES 加密         AES 解密         AES 加密
   (key0)           (key1)           (key2)           (key3)
     |                |                |                |
     v                v                v                v
  state0'          state1'          state2'          state3'
```

### 3.3 AesGenerator4R

AesGenerator4R的工作方式与AesGenerator1R类似，只是每列使用4轮。列0和1使用与列2和3不同的密钥集。

```
state0 (16 B)    state1 (16 B)    state2 (16 B)    state3 (16 B)
     |                |                |                |
 AES 解密         AES 加密         AES 解密         AES 加密
   (key0)           (key0)           (key4)           (key4)
     |                |                |                |
     v                v                v                v
 AES 解密         AES 加密         AES 解密         AES 加密
   (key1)           (key1)           (key5)           (key5)
     |                |                |                |
     v                v                v                v
 AES 解密         AES 加密         AES 解密         AES 加密
   (key2)           (key2)           (key6)           (key6)
     |                |                |                |
     v                v                v                v
 AES 解密         AES 加密         AES 解密         AES 加密
   (key3)           (key3)           (key7)           (key7)
     |                |                |                |
     v                v                v                v
  state0'          state1'          state2'          state3'
```

AesGenerator4R使用以下8个轮密钥：

```
key0 = dd aa 21 64 db 3d 83 d1 2b 6d 54 2f 3f d2 e5 99
key1 = 50 34 0e b2 55 3f 91 b6 53 9d f7 06 e5 cd df a5
key2 = 04 d9 3e 5c af 7b 5e 51 9f 67 a4 0a bf 02 1c 17
key3 = 63 37 62 85 08 5d 8f e7 85 37 67 cd 91 d2 de d8
key4 = 73 6f 82 b5 a6 a7 d6 e3 6d 8b 51 3d b4 ff 9e 22
key5 = f3 6b 56 c7 d9 b3 10 9c 4e 4d 02 e9 d2 b7 72 b2
key6 = e7 c9 73 f2 8b a3 65 f7 0a 66 a9 2b a7 ef 3b f6
key7 = 09 d6 7c 7a de 39 58 91 fd d1 06 0c 2d 76 b0 c0
```

这些密钥是通过以下方式生成的：
```
key0, key1, key2, key3 = Hash512("RandomX AesGenerator4R keys 0-3")
key4, key5, key6, key7 = Hash512("RandomX AesGenerator4R keys 4-7")
```

### 3.4 AesHash1R

AesHash1R计算其输入的512位指纹。

AesHash1R有一个64字节的内部状态，排列成四列，每列16字节。初始状态为：

```
state0 = 0d 2c b5 92 de 56 a8 9f 47 db 82 cc ad 3a 98 d7
state1 = 6e 99 8d 33 98 b7 c7 15 5a 12 9e f5 57 80 e7 ac
state2 = 17 00 77 6a d0 c7 62 ae 6b 50 79 50 e4 7c a0 e8
state3 = 0c 24 0a 63 8d 82 ad 07 05 00 a1 79 48 49 99 7e
```

初始状态向量是通过以下方式生成的：
```
state0, state1, state2, state3 = Hash512("RandomX AesHash1R state")
```

输入按64字节块处理。每个输入块被视为四个AES轮密钥`key0`、`key1`、`key2`、`key3`的集合。每个状态列使用相应的轮密钥进行一轮AES加密（列0、2）或解密（列1、3）：

```
state0 (16 B)    state1 (16 B)    state2 (16 B)    state3 (16 B)
     |                |                |                |
 AES 加密         AES 解密         AES 加密         AES 解密
   (key0)           (key1)           (key2)           (key3)
     |                |                |                |
     v                v                v                v
  state0'          state1'          state2'          state3'
```

当所有输入字节都被处理后，状态使用以下额外密钥进行两轮额外的AES处理（每轮一个密钥，所有列使用相同的密钥对）：

```
xkey0 = 89 83 fa f6 9f 94 24 8b bf 56 dc 90 01 02 89 06
xkey1 = d1 63 b2 61 3c e0 f4 51 c6 43 10 ee 9b f9 18 ed
```

额外密钥是通过以下方式生成的：
```
xkey0, xkey1 = Hash256("RandomX AesHash1R xkeys")
```

```
state0 (16 B)    state1 (16 B)    state2 (16 B)    state3 (16 B)
     |                |                |                |
 AES 加密         AES 解密         AES 加密         AES 解密
   (xkey0)          (xkey0)          (xkey0)          (xkey0)
     |                |                |                |
     v                v                v                v
 AES 加密         AES 解密         AES 加密         AES 解密
   (xkey1)          (xkey1)          (xkey1)          (xkey1)
     |                |                |                |
     v                v                v                v
finalState0      finalState1      finalState2      finalState3 
```

最终状态是函数的输出。

### 3.5 BlakeGenerator

BlakeGenerator是一个基于Blake2b哈希函数的简单伪随机数生成器。它有一个64字节的内部状态`S`。

#### 3.5.1 初始化

内部状态从种子值`K`（0-60字节长）初始化。种子值写入内部状态并用零填充。然后内部状态初始化为`S = Hash512(S)`。

#### 3.5.2 随机数生成

生成器可以通过从其内部状态`S`提供数据一次生成1字节或4字节。如果没有足够的未使用字节剩余，内部状态重新初始化为`S = Hash512(S)`。

## 4. 虚拟机

RandomX虚拟机的组件在图4.1中总结。

*图4.1 - 虚拟机*

![Imgur](https://i.imgur.com/Enk42b8.png)

VM是一个复杂指令集计算机（[CISC](https://en.wikipedia.org/wiki/Complex_instruction_set_computer)）。所有数据都以小端字节序加载和存储。有符号整数使用[二进制补码](https://en.wikipedia.org/wiki/Two%27s_complement)表示。

### 4.1 数据集

数据集在第7章中详细描述。它是一个大型只读缓冲区。其大小等于`RANDOMX_DATASET_BASE_SIZE + RANDOMX_DATASET_EXTRA_SIZE`字节。每个程序只使用数据集大小为`RANDOMX_DATASET_BASE_SIZE`的随机子集。所有数据集访问都读取对齐的64字节项。

### 4.2 暂存器

暂存器表示VM的工作空间内存。其大小为`RANDOMX_SCRATCHPAD_L3`字节，分为3个"级别"：

* 整个暂存器是第三级"L3"。
* 暂存器的前`RANDOMX_SCRATCHPAD_L2`字节是第二级"L2"。
* 暂存器的前`RANDOMX_SCRATCHPAD_L1`字节是第一级"L1"。

暂存器级别是包含的，即L3包含L2和L1，L2包含L1。

要访问特定的暂存器级别，对内存地址应用按位AND操作和表4.2.1中列出的掩码。

*表4.2.1：暂存器访问掩码*

|级别|8字节对齐掩码|64字节对齐掩码|
|---------|-|-|
|L1|`(RANDOMX_SCRATCHPAD_L1 - 1) & ~7`|-|
|L2|`(RANDOMX_SCRATCHPAD_L2 - 1) & ~7`|-|
|L3|`(RANDOMX_SCRATCHPAD_L3 - 1) & ~7`|`(RANDOMX_SCRATCHPAD_L3 - 1) & ~63`|

### 4.3 寄存器

VM有8个整数寄存器`r0`-`r7`（R组）和总共12个浮点寄存器，分为3组：`f0`-`f3`（F组）、`e0`-`e3`（E组）和`a0`-`a3`（A组）。整数寄存器为64位宽，而浮点寄存器为128位宽，包含浮点格式的一对数字。浮点寄存器的下半部分和上半部分不能单独寻址。

此外，还有3个内部寄存器`ma`、`mx`和`fprc`。

整数寄存器`r0`-`r7`可以是整数指令的源或目标操作数，或者可以用作访问暂存器的地址寄存器。

浮点寄存器`a0`-`a3`是只读的，其值对于给定的VM程序是固定的。它们可以是任何浮点指令的源操作数。这些寄存器的值限制在区间`[1, 4294967296)`内。

浮点寄存器`f0`-`f3`是"加法"寄存器，可以是浮点加法和减法指令的目标。这些寄存器的绝对值不会超过约`3.0e+14`。

浮点寄存器`e0`-`e3`是"乘法"寄存器，可以是浮点乘法、除法和平方根指令的目标。它们的值始终为正。

`ma`和`mx`是内存寄存器。两者都是32位宽。`ma`包含下一个数据集读取的内存地址，`mx`包含下一个数据集预取的地址。`ma`和`mx`寄存器的值始终对齐为64的倍数。

2位`fprc`寄存器根据表4.3.1确定所有浮点操作的舍入模式。四种舍入模式由IEEE 754标准定义。

*表4.3.1：舍入模式*

|`fprc`|舍入模式|
|-------|------------|
|0|roundTiesToEven|
|1|roundTowardNegative|
|2|roundTowardPositive|
|3|roundTowardZero|

#### 4.3.1 F组寄存器转换

当从内存读取的8字节值要转换为F组寄存器值或操作数时，它被解释为一对32位有符号整数（小端格式，二进制补码格式）并转换为浮点格式。这种转换是精确的，不需要舍入，因为只需要30位尾数来表示整数值。

#### 4.3.2 E组寄存器转换

当从内存读取的8字节值要转换为E组寄存器值或操作数时，应用与F组寄存器相同的转换过程（见4.3.1），并对两个浮点值中的每一个进行额外的后处理步骤：

1. 符号位设置为`0`。
2. 指数的位0-2设置为常量值<code>011<sub>2</sub></code>。
3. 指数的位3-6设置为第4.5.6章中描述的指数掩码的值。此值对于给定的VM程序是固定的。
4. 尾数的底部22位设置为第4.5.6章中描述的尾数掩码的值。此值对于给定的VM程序是固定的。

### 4.4 程序缓冲区

程序缓冲区存储要由VM执行的程序。程序由`RANDOMX_PROGRAM_SIZE`条指令组成。每条指令由8字节字编码。指令集在第5章中描述。

### 4.5 VM编程

VM需要`128 + 8 * RANDOMX_PROGRAM_SIZE`字节进行编程。这分为两部分：

* `128`字节配置数据 = 16个四字（16×8字节），按表4.5.1使用
* `8 * RANDOMX_PROGRAM_SIZE`字节程序数据，直接复制到程序缓冲区

*表4.5.1 - 配置数据*

|四字|描述|
|-----|-----------|
|0|初始化寄存器`a0`的低半部分|
|1|初始化寄存器`a0`的高半部分|
|2|初始化寄存器`a1`的低半部分|
|3|初始化寄存器`a1`的高半部分|
|4|初始化寄存器`a2`的低半部分|
|5|初始化寄存器`a2`的高半部分|
|6|初始化寄存器`a3`的低半部分|
|7|初始化寄存器`a3`的高半部分|
|8|初始化寄存器`ma`|
|9|（保留）|
|10|初始化寄存器`mx`|
|11|（保留）|
|12|选择地址寄存器|
|13|选择数据集偏移|
|14|初始化E组寄存器低半部分的寄存器掩码|
|15|初始化E组寄存器高半部分的寄存器掩码|

#### 4.5.2 A组寄存器初始化

浮点寄存器`a0`-`a3`的值使用配置四字0-7初始化，具有以下值：

<code>+1.fraction x 2<sup>exponent</sup></code>

尾数具有完整的52位精度，指数值范围为0到31。这些值根据表4.5.2从初始化四字（小端格式）获得。

*表4.5.2 - A组寄存器初始化*

|位|描述|
|----|-----------|
|0-51|尾数|
|52-58|（保留）|
|59-63|指数|

#### 4.5.3 内存寄存器

寄存器`ma`和`mx`使用四字8和10的低32位以小端格式初始化。

#### 4.5.4 地址寄存器

四字12的位0-3用于选择程序执行的4个地址寄存器。每个位根据表4.5.3从一对整数寄存器中选择一个寄存器。

*表4.5.3 - 地址寄存器*

|地址寄存器（位）|值=0|值=1|
|----------------------|-|-|
|`readReg0` (0)|`r0`|`r1`|
|`readReg1` (1)|`r2`|`r3`|
|`readReg2` (2)|`r4`|`r5`|
|`readReg3` (3)|`r6`|`r7`|

#### 4.5.5 数据集偏移

`datasetOffset`计算为四字13除以`RANDOMX_DATASET_EXTRA_SIZE / 64 + 1`的余数。结果乘以`64`。此偏移在从数据集读取值时使用。

#### 4.5.6 E组寄存器掩码

这些掩码用于E组寄存器的转换（见4.3.2）。低半部分和高半部分各自有从四字14和15初始化的掩码。尾数掩码由初始化四字的位0-21给出，指数掩码由位60-63给出。

### 4.6 VM执行

在VM执行期间，使用3个额外的临时寄存器：`ic`、`spAddr0`和`spAddr1`。程序执行包括初始化和循环执行。

#### 4.6.1 初始化

1. `ic`寄存器设置为`RANDOMX_PROGRAM_ITERATIONS`。
2. `spAddr0`设置为`mx`的值。
3. `spAddr1`设置为`ma`的值。
4. 所有整数寄存器`r0`-`r7`的值设置为零。

#### 4.6.2 循环执行

下面描述的循环重复执行，直到`ic`寄存器的值达到零。

1. 计算寄存器`readReg0`和`readReg1`的XOR（见表4.5.3），`spAddr0`与结果的低32位进行XOR，`spAddr1`与高32位进行XOR。
2. 使用`spAddr0`从暂存器级别3执行64字节对齐读取（使用表4.2.1中的掩码）。64字节按顺序`r0`-`r7`与所有整数寄存器进行XOR。
3. 使用`spAddr1`从暂存器级别3执行64字节对齐读取（使用表4.2.1中的掩码）。每个浮点寄存器`f0`-`f3`和`e0`-`e3`使用8字节值根据第4.3.1和4.3.2章中的转换规则进行初始化。
4. 执行存储在程序缓冲区中的256条指令。
5. `mx`寄存器与寄存器`readReg2`和`readReg3`的低32位进行XOR（见表4.5.3）。
6. 从数据集预取地址`datasetOffset + mx % RANDOMX_DATASET_BASE_SIZE`处的64字节数据集项（将在下一次迭代中使用）。
7. 从数据集加载地址`datasetOffset + ma % RANDOMX_DATASET_BASE_SIZE`处的64字节数据集项。64字节按顺序`r0`-`r7`与所有整数寄存器进行XOR。
8. 交换寄存器`mx`和`ma`的值。
9. 所有整数寄存器`r0`-`r7`的值写入地址`spAddr1`处的暂存器（L3）（64字节对齐）。
10. 寄存器`f0`与寄存器`e0`进行XOR，结果存储在寄存器`f0`中。寄存器`f1`与寄存器`e1`进行XOR，结果存储在寄存器`f1`中。寄存器`f2`与寄存器`e2`进行XOR，结果存储在寄存器`f2`中。寄存器`f3`与寄存器`e3`进行XOR，结果存储在寄存器`f3`中。
11. 寄存器`f0`-`f3`的值写入地址`spAddr0`处的暂存器（L3）（64字节对齐）。
12. `spAddr0`和`spAddr1`都设置为零。
13. `ic`减1。

## 5. 指令集

VM在特殊指令集中执行程序，该指令集的设计使得任何随机的8字节字都是有效指令，任何有效指令序列都是有效程序。因为没有"语法"规则，生成随机程序就像用随机数据填充程序缓冲区一样简单。

### 5.1 指令编码

每条指令字为64位长。指令字段按图5.1所示编码。

*图5.1 - 指令编码*

![Imgur](https://i.imgur.com/FtkWRwe.png)

#### 5.1.1 操作码
有256个操作码，分布在29条不同的指令中。每条指令可以使用多个操作码编码（操作码数量指定随机程序中指令的频率）。

*表5.1.1：指令组*

|组|# 指令|# 操作码||
|---------|-----------------|----|-|
|整数 |17|120|46.9%|
|浮点 |9|94|36.7%|
|控制 |2|26|10.2%|
|存储 |1|16|6.2%|
||**29**|**256**|**100%**

所有指令在下面的第5.2-5.5章中描述。

#### 5.1.2 dst
目标寄存器。只使用位0-1（寄存器组A、F、E）或0-2（组R、F+E）根据表5.1.2编码寄存器。

*表5.1.2：可寻址寄存器组*

|索引|R|A|F|E|F+E|
|--|--|--|--|--|--|
|0|`r0`|`a0`|`f0`|`e0`|`f0`|
|1|`r1`|`a1`|`f1`|`e1`|`f1`|
|2|`r2`|`a2`|`f2`|`e2`|`f2`|
|3|`r3`|`a3`|`f3`|`e3`|`f3`|
|4|`r4`||||`e0`|
|5|`r5`||||`e1`|
|6|`r6`||||`e2`|
|7|`r7`||||`e3`|

#### 5.1.3 src

`src`标志根据表5.1.2编码源操作数寄存器（只使用位0-1或0-2）。

当`dst`和`src`编码相同寄存器时，一些整数指令使用常量值作为源操作数（见表5.2.1）。

对于寄存器-内存指令，源操作数用于计算内存地址。

#### 5.1.4 mod

`mod`标志编码为：

*表5.1.3：mod标志编码*

|`mod`位|描述|值范围|
|----|--------|----|
|0-1|`mod.mem`标志|0-3|
|2-3|`mod.shift`标志|0-3|
|4-7|`mod.cond`标志|0-15|

`mod.mem`标志在从内存读取或写入时在暂存器级别L1和L2之间选择，除了两种情况：

* 它是内存读取且`dst`和`src`编码相同寄存器
* 它是内存写入且`mod.cond`是14或15

在这两种情况下，暂存器级别是L3（见表5.1.4）。

*表5.1.4：内存访问暂存器级别*

|条件|暂存器级别|
|---------|-|
|`src == dst`（读取）|L3|
|`mod.cond >= 14`（写入）|L3|
|`mod.mem == 0`|L2|
|`mod.mem != 0`|L1|

读取/写入的地址通过将按位AND操作应用于地址和表4.2.1中列出的8字节对齐地址掩码来计算。

`mod.cond`和`mod.shift`标志由一些指令使用（见5.2、5.4）。

#### 5.1.5 imm32
32位立即值，可以用作源操作数，并用于计算内存操作的地址。立即值符号扩展为64位，除非另有说明。

### 5.2 整数指令
对于整数指令，目标始终是整数寄存器（寄存器组R）。源操作数（如果适用）可以是整数寄存器或内存值。如果`dst`和`src`引用相同寄存器，大多数指令使用`0`或`imm32`而不是寄存器。这在表5.2.1的'src == dst'列中指示。

`[mem]`表示从地址`src + imm32`加载的8字节值的内存操作数。

*表5.2.1 整数指令*

|频率|指令|dst|src|`src == dst ?`|操作|
|-|-|-|-|-|-|
|16/256|IADD_RS|R|R|`src = dst`|`dst = dst + (src << mod.shift) (+ imm32)`|
|7/256|IADD_M|R|R|`src = 0`|`dst = dst + [mem]`|
|16/256|ISUB_R|R|R|`src = imm32`|`dst = dst - src`|
|7/256|ISUB_M|R|R|`src = 0`|`dst = dst - [mem]`|
|16/256|IMUL_R|R|R|`src = imm32`|`dst = dst * src`|
|4/256|IMUL_M|R|R|`src = 0`|`dst = dst * [mem]`|
|4/256|IMULH_R|R|R|`src = dst`|`dst = (dst * src) >> 64`|
|1/256|IMULH_M|R|R|`src = 0`|`dst = (dst * [mem]) >> 64`|
|4/256|ISMULH_R|R|R|`src = dst`|`dst = (dst * src) >> 64`（有符号）|
|1/256|ISMULH_M|R|R|`src = 0`|`dst = (dst * [mem]) >> 64`（有符号）|
|8/256|IMUL_RCP|R|-|-|<code>dst = 2<sup>x</sup> / imm32 * dst</code>|
|2/256|INEG_R|R|-|-|`dst = -dst`|
|15/256|IXOR_R|R|R|`src = imm32`|`dst = dst ^ src`|
|5/256|IXOR_M|R|R|`src = 0`|`dst = dst ^ [mem]`|
|8/256|IROR_R|R|R|`src = imm32`|`dst = dst >>> src`|
|2/256|IROL_R|R|R|`src = imm32`|`dst = dst <<< src`|
|4/256|ISWAP_R|R|R|`src = dst`|`temp = src; src = dst; dst = temp`|

#### 5.2.1 IADD_RS

此指令将两个寄存器的值相加（模2<sup>64</sup>）。第二个操作数的值左移0-3位（由`mod.shift`标志确定）。此外，如果`dst`是寄存器`r5`，则将立即值`imm32`加到结果中。

#### 5.2.2 IADD_M

64位整数加法操作（模2<sup>64</sup>执行），具有内存源操作数。

#### 5.2.3 ISUB_R, ISUB_M

64位整数减法（模2<sup>64</sup>执行）。ISUB_R使用寄存器源操作数，ISUB_M使用内存源操作数。

#### 5.2.4 IMUL_R, IMUL_M

64位整数乘法（模2<sup>64</sup>执行）。IMUL_R使用寄存器源操作数，IMUL_M使用内存源操作数。

#### 5.2.5 IMULH_R, IMULH_M, ISMULH_R, ISMULH_M
这些指令输出整个128位乘法结果的高64位。有符号和无符号乘法的结果不同（IMULH是无符号，ISMULH是有符号）。具有寄存器源操作数的变体在`dst`等于`src`时执行平方操作。

#### 5.2.6 IMUL_RCP
如果`imm32`等于0或是2的幂，IMUL_RCP是无操作。在其他情况下，指令将目标寄存器乘以`imm32`的倒数（立即值零扩展并视为无符号）。倒数计算为<code>rcp = 2<sup>x</sup> / imm32</code>，通过选择最大的整数`x`使得<code>rcp < 2<sup>64</sup></code>。

#### 5.2.7 INEG_R
执行目标寄存器的二进制补码取反。

#### 5.2.8 IXOR_R, IXOR_M
64位异或操作。IXOR_R使用寄存器源操作数，IXOR_M使用内存源操作数。

#### 5.2.9 IROR_R, IROL_R
执行目标寄存器的循环移位（旋转）。源操作数（移位计数）隐式掩码为6位。IROR向右旋转位，IROL向左旋转。

#### 5.2.9 ISWAP_R
此指令交换两个寄存器的值。如果源和目标引用相同寄存器，结果是无操作。

### 5.3 浮点指令
对于浮点指令，目标可以是F组或E组寄存器。源操作数是A组寄存器或内存值。

`[mem]`表示从地址`src + imm32`加载的8字节值的内存操作数，并根据第4.3.1章（F组）或4.3.2章（E组）中的规则转换。内存操作数的下半部分和上半部分分别表示为`[mem][0]`和`[mem][1]`。

所有浮点操作根据`fprc`寄存器的当前值舍入（见表4.3.1）。由于浮点寄存器值的限制，没有操作产生`NaN`或非正规数。

*表5.3.1 浮点指令*

|频率|指令|dst|src|操作|
|-|-|-|-|-|
|4/256|FSWAP_R|F+E|-|`(dst0, dst1) = (dst1, dst0)`|
|16/256|FADD_R|F|A|`(dst0, dst1) = (dst0 + src0, dst1 + src1)`|
|5/256|FADD_M|F|R|`(dst0, dst1) = (dst0 + [mem][0], dst1 + [mem][1])`|
|16/256|FSUB_R|F|A|`(dst0, dst1) = (dst0 - src0, dst1 - src1)`|
|5/256|FSUB_M|F|R|`(dst0, dst1) = (dst0 - [mem][0], dst1 - [mem][1])`|
|6/256|FSCAL_R|F|-|<code>(dst0, dst1) = (-2<sup>x0</sup> * dst0, -2<sup>x1</sup> * dst1)</code>|
|32/256|FMUL_R|E|A|`(dst0, dst1) = (dst0 * src0, dst1 * src1)`|
|4/256|FDIV_M|E|R|`(dst0, dst1) = (dst0 / [mem][0], dst1 / [mem][1])`|
|6/256|FSQRT_R|E|-|`(dst0, dst1) = (√dst0, √dst1)`|

#### 5.3.1 FSWAP_R

交换目标寄存器的下半部分和上半部分。这是唯一适用于F和E寄存器组的指令。

#### 5.3.2 FADD_R, FADD_M

双精度浮点加法。FADD_R使用A组寄存器源操作数，FADD_M使用内存操作数。

#### 5.3.3 FSUB_R, FSUB_M

双精度浮点减法。FSUB_R使用A组寄存器源操作数，FSUB_M使用内存操作数。

#### 5.3.4 FSCAL_R
此指令对数字取反并乘以<code>2<sup>x</sup></code>。`x`通过取偏置指数的4个最低有效数字并将其解释为使用数字集`{+1, -1}`而不是传统的`{0, 1}`的二进制数来计算。`x`的可能值是从-15到+15的所有奇数。

上述数学操作等价于二进制表示与值`0x80F0000000000000`的按位XOR。

#### 5.3.5 FMUL_R

双精度浮点乘法。此指令只使用寄存器源操作数。

#### 5.3.6 FDIV_M

双精度浮点除法。此指令只使用内存源操作数。

#### 5.3.7 FSQRT_R

目标寄存器的双精度浮点平方根。

### 5.4 控制指令

有2条控制指令。

*表5.4.1 - 控制指令*

|频率|指令|dst|src|操作|
|-|-|-|-|-|
|1/256|CFROUND|-|R|`fprc = src >>> imm32`
|25/256|CBRANCH|R|-|`dst = dst + cimm`，条件跳转

#### 5.4.1 CFROUND
此指令通过将源寄存器右移`imm32`位并取2个最低有效位来计算2位值（源寄存器的值不受影响）。结果存储在`fprc`寄存器中。这会改变所有后续浮点指令的舍入模式。

#### 5.4.2 CBRANCH

此指令将立即值`cimm`（从`imm32`构造，见下文）加到目标寄存器，然后基于目标寄存器的值在程序缓冲区中执行条件跳转。跳转的目标是寄存器`dst`上次修改时指令后面的指令。

在每次程序迭代开始时，所有寄存器都被视为未修改。在以下情况下，寄存器被视为被指令修改：

* 它是整数指令的目标寄存器，除了IMUL_RCP和ISWAP_R。
* 它是IMUL_RCP的目标寄存器且`imm32`不为零或2的幂。
* 它是ISWAP_R的源或目标寄存器，且目标和源寄存器不同。
* CBRANCH指令被视为修改所有整数寄存器。

如果寄存器`dst`尚未被修改，跳转目标是程序缓冲区中的第一条指令。

CBRANCH指令执行以下步骤：

1. 计算常量`b`为`mod.cond + RANDOMX_JUMP_OFFSET`。
1. 构造常量`cimm`为符号扩展的`imm32`，位`b`设置为1，位`b-1`设置为0（如果`b > 0`）。
1. 将`cimm`加到目标寄存器。
1. 如果目标寄存器的位`b`到`b + RANDOMX_JUMP_BITS - 1`为零，则执行跳转（目标是`dst`上次修改的指令后面的指令）。

立即值和寄存器值中的位从0到63编号，0是最低有效位。例如，对于`b = 10`和`RANDOMX_JUMP_BITS = 8`，位排列如下：

```
cimm = SSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSMMMMMMMMMMMMMMMMMMMMM10MMMMMMMMM
 dst = ..............................................XXXXXXXX..........
```

`S`是从`imm32`复制的符号位。`M`表示`imm32`的位。第9位设置为0，第10位设置为1。此值将加到`dst`。

第二行使用`X`标记将被条件检查的`dst`的位。如果在添加`cimm`后所有这些位都为0，则执行跳转。

CBRANCH指令的构造确保程序中不可能出现无限循环。

### 5.5 存储指令
有一条用于整数值的显式存储指令。

`[mem]`表示目标是地址`dst + imm32`处的8字节值。

*表5.5.1 - 存储指令*

|频率|指令|dst|src|操作|
|-|-|-|-|-|
|16/256|ISTORE|R|R|`[mem] = src`

#### 5.5.1 ISTORE
此指令将源整数寄存器的值存储到从目标寄存器的值计算的地址处的内存中。`src`和`dst`可以是相同寄存器。

## 6. SuperscalarHash

SuperscalarHash是一个自定义扩散函数，设计为仅使用CPU的整数ALU尽可能多地消耗功率。

SuperscalarHash的输入和输出是8个整数寄存器`r0`-`r7`，每个64位宽。SuperscalarHash的输出用于构造数据集（见第7.3章）。

### 6.1 指令
SuperscalarHash的主体是可以在虚拟机上运行的随机指令序列。SuperscalarHash使用表6.1.1中列出的仅整数寄存器-寄存器指令的简化集。`dst`指目标寄存器，`src`指源寄存器。

*表6.1.1 - SuperscalarHash指令*

|频率 †|指令|宏操作|操作|规则|
|-|-|-|-|-|
|0.11|ISUB_R|`sub_rr`|`dst = dst - src`|`dst != src`|
|0.11|IXOR_R|`xor_rr`|`dst = dst ^ src`|`dst != src`|
|0.11|IADD_RS|`lea_sib`|`dst = dst + (src << mod.shift)`|`dst != src`，`dst != r5`
|0.22|IMUL_R|`imul_rr`|`dst = dst * src`|`dst != src`|
|0.11|IROR_C|`ror_ri`|`dst = dst >>> imm32`|`imm32 % 64 != 0`|
|0.10|IADD_C|`add_ri`|`dst = dst + imm32`|
|0.10|IXOR_C|`xor_ri`|`dst = dst ^ imm32`|
|0.03|IMULH_R|`mov_rr`,`mul_r`,`mov_rr`|`dst = (dst * src) >> 64`|
|0.03|ISMULH_R|`mov_rr`,`imul_r`,`mov_rr`|`dst = (dst * src) >> 64`（有符号）|
|0.06|IMUL_RCP|`mov_ri`,`imul_rr`|<code>dst = 2<sup>x</sup> / imm32 * dst</code>|`imm32 != 0`，<code>imm32 != 2<sup>N</sup></code>|

† 频率是近似的。指令基于复杂规则生成。

#### 6.1.1 ISUB_R
见第5.2.3章。源和目标始终是不同的寄存器。

#### 6.1.2 IXOR_R
见第5.2.8章。源和目标始终是不同的寄存器。

#### 6.1.3 IADD_RS
见第5.2.1章。源和目标始终是不同的寄存器，寄存器`r5`不能是目标。

#### 6.1.4 IMUL_R
见第5.2.4章。源和目标始终是不同的寄存器。

#### 6.1.5 IROR_C
目标寄存器向右旋转。旋转计数由`imm32`掩码为6位给出，不能为0。

#### 6.1.6 IADD_C
符号扩展的`imm32`加到目标寄存器。

#### 6.1.7 IXOR_C
目标寄存器与符号扩展的`imm32`进行XOR。

#### 6.1.8 IMULH_R, ISMULH_R
见第5.2.5章。

#### 6.1.9 IMUL_RCP
见第5.2.6章。`imm32`从不等于0或2的幂。

### 6.2 参考CPU

与标准RandomX程序不同，SuperscalarHash程序使用严格的规则集生成，以在超标量CPU上实现最大性能。为此，生成器运行参考CPU的模拟。

参考CPU大致基于[Intel Ivy Bridge微架构](https://en.wikipedia.org/wiki/Ivy_Bridge_(microarchitecture))。它具有以下属性：

* CPU有3个整数执行端口P0、P1和P5，可以并行执行指令。乘法只能在端口P1上运行。
* 表6.1.1中列出的每条Superscalar指令由一个或多个*宏操作*组成。每个宏操作具有表6.2.1中显示的某些执行延迟（周期）和大小（字节）。
* 表6.2.1中列出的每个宏操作由0-2个*微操作*组成，可以进入3个执行端口的子集。如果宏操作由2个微操作组成，两者必须一起执行。
* CPU每个周期最多可以解码16字节代码，每个周期最多4个微操作。

*表6.2.1 - 宏操作*

|宏操作|延迟|大小|第1个微操作|第2个微操作|
|-|-|-|-|-|
|`sub_rr`|1|3|P015|-|
|`xor_rr`|1|3|P015|-|
|`lea_sib`|1|4|P01|-|
|`imul_rr`|3|4|P1|-|
|`ror_ri`|1|4|P05|-|
|`add_ri`|1|7, 8, 9|P015|-|
|`xor_ri`|1|7, 8, 9|P015|-|
|`mov_rr`|0|3|-|-|
|`mul_r`|4|3|P1|P5|
|`imul_r`|4|3|P1|P5|
|`mov_ri`|1|10|P015|-|

* P015 - 微操作可以在任何端口执行
* P01 - 微操作可以在端口P0或P1执行
* P05 - 微操作可以在端口P0或P5执行
* P1 - 微操作只能在端口P1执行
* P5 - 微操作只能在端口P5执行

宏操作`add_ri`和`xor_ri`可以可选地填充到8或9字节大小以进行代码对齐。`mov_rr`的执行延迟为0，不使用执行端口，但在解码阶段仍占用空间（见第6.3.1章）。

### 6.3 CPU模拟

SuperscalarHash程序生成以最大化参考CPU所有3个执行端口的使用。生成包括4个阶段：

* 解码阶段
* 指令选择
* 端口分配
* 操作数分配

当满足两个条件之一时，程序生成完成：

1. 指令被调度在等于或大于`RANDOMX_SUPERSCALAR_LATENCY`的周期执行
1. 生成的指令数量达到`3 * RANDOMX_SUPERSCALAR_LATENCY + 2`。

#### 6.3.1 解码阶段

生成器以3或4个宏操作槽的组产生指令，使得每个组的大小恰好为16字节。

*表6.3.1 - 解码器配置*

|解码器组|配置|
|-------------|-------------|
|0|4-8-4|
|1|7-3-3-3|
|2|3-7-3-3|
|3|4-9-3|
|4|4-4-4-4|
|5|3-3-10|

解码器组选择的规则如下：

* 如果当前处理的指令是IMULH_R或ISMULH_R，下一个解码组是组5（唯一以3字节槽开始且只有3个槽的组）。
* 如果已生成的乘法总数小于或等于当前解码周期，下一个解码组是组4。
* 如果当前处理的指令是IMUL_RCP，下一个解码组是组0或3（必须以4字节槽开始以进行乘法）。
* 否则从组0-3中随机选择解码组。

#### 6.3.2 指令选择

指令基于当前解码组槽的大小选择 - 见表6.3.2。

*表6.3.2 - 解码器配置*

|槽大小|注意|指令|
|-------------|-------------|-----|
|3|-|ISUB_R, IXOR_R
|3|组中的最后一个槽|ISUB_R, IXOR_R, IMULH_R, ISMULH_R|
|4|解码组4，不是最后一个槽|IMUL_R|
|4|-|IROR_C, IADD_RS|
|7,8,9|-|IADD_C, IXOR_C|
|10|-|IMUL_RCP|

#### 6.3.3 端口分配

微操作在可用端口空闲时立即发布到执行端口。调度通过按P5 -> P0 -> P1的顺序检查端口可用性乐观地进行，以避免可以进入任何端口的指令过载端口P1（乘法）。指令的所有微操作可以执行的周期称为'scheduleCycle'。

#### 6.3.4 操作数分配

首先选择源操作数（如果需要）。从在指令的'scheduleCycle'可用的寄存器组中选择。如果其最后操作的延迟已经过去，则寄存器可用。

目标操作数使用更严格的规则选择（见表6.1.1中的'规则'列）：

* 值必须在所需周期准备就绪
* 不能与源寄存器相同，除非指令允许（见表6.1.1中的'规则'列）
    * 这避免了可优化的操作，如`reg ^ reg`或`reg - reg`
    * 它还增加了寄存器值的混合
* 寄存器不能连续相乘两次，除非`allowChainedMul`为真
    * 这避免了由于过度乘法而在寄存器中积累尾随零
    * 如果尝试查找源/目标寄存器失败，`allowChainedMul`设置为真（这很罕见，但防止生成器的灾难性失败）
* 应用于寄存器的最后一条指令或其源必须与当前指令不同
    * 这避免了可优化的指令序列，如`r1 = r1 ^ r2; r1 = r1 ^ r2`（可以消除）或`reg = reg >>> C1; reg = reg >>> C2`（可以简化为一次旋转）或`reg = reg + C1; reg = reg + C2`（可以简化为一次加法）
* 寄存器`r5`不能是IADD_RS指令的目标（x86 lea指令的限制）

## 7. 数据集

数据集是一个只读内存结构，在程序执行期间使用（第4.6.2章，步骤6和7）。数据集的大小为`RANDOMX_DATASET_BASE_SIZE + RANDOMX_DATASET_EXTRA_SIZE`字节，分为64字节的'项'。

为了允许使用较少内存进行PoW验证，数据集使用称为"缓存"的中间结构分两步构造，可以用于动态计算数据集项。

整个数据集从密钥值`K`构造，这是RandomX的输入参数。每次密钥值改变时，整个数据集都需要重新计算。图7.1显示了数据集构造过程。注意：`K`的最大支持长度为60字节。使用更长的密钥会导致实现定义的行为。

*图7.1 - 数据集构造*

![Imgur](https://i.imgur.com/86h5SbW.png)

### 7.1 缓存构造

密钥`K`使用Argon2d的"内存填充"函数扩展到缓存，参数按表7.1.1。密钥用作"密码"字段。

*表7.1.1 - Argon2参数*

|参数|值|
|------------|--|
|并行度|`RANDOMX_ARGON_LANES`|
|输出大小|0|
|内存|`RANDOMX_ARGON_MEMORY`|
|迭代次数|`RANDOMX_ARGON_ITERATIONS`|
|版本|`0x13`|
|哈希类型|0（Argon2d）|
|密码|密钥值`K`|
|盐值|`RANDOMX_ARGON_SALT`
|密钥大小|0|
|关联数据大小|0|

省略Argon2的终结器和输出计算步骤。输出是填充的内存数组。

### 7.2 SuperscalarHash初始化

密钥值`K`用于初始化BlakeGenerator（见第3.5章），然后用于生成8个SuperscalarHash实例用于数据集初始化。

### 7.3 数据集块生成
数据集项从0开始按`itemNumber`顺序编号。每个64字节数据集项使用8个SuperscalarHash函数（根据第7.2章生成）并通过XOR随机选择的缓存数据（根据第7.1章构造）独立生成。

项数据由8个64位整数寄存器表示：`r0`-`r7`。

1. 寄存器值按以下方式初始化（`*` = 乘法，`^` = XOR）：
    * `r0 = (itemNumber + 1) * 6364136223846793005`
    * `r1 = r0 ^ 9298411001130361340`
    * `r2 = r0 ^ 12065312585734608966`
    * `r3 = r0 ^ 9306329213124626780`
    * `r4 = r0 ^ 5281919268842080866`
    * `r5 = r0 ^ 10536153434571861004`
    * `r6 = r0 ^ 3398623926847679864`
    * `r7 = r0 ^ 9549104520008361294`
1. 设`cacheIndex = itemNumber`
1. 设`i = 0`
1. 从缓存加载64字节项。项索引由`cacheIndex`模缓存中64字节项的总数给出。
1. 执行`SuperscalarHash[i](r0, r1, r2, r3, r4, r5, r6, r7)`，其中`SuperscalarHash[i]`指第i个SuperscalarHash函数。这会修改寄存器`r0`-`r7`的值。
1. 所有寄存器与步骤4中加载的64字节进行XOR（按顺序`r0`-`r7`每列8字节）。
1. 将`cacheIndex`设置为在步骤5中执行的SuperscalarHash函数中具有最长依赖链的寄存器的值。
1. 设`i = i + 1`，如果`i < RANDOMX_CACHE_ACCESSES`则返回步骤4。
1. 按小端格式连接寄存器`r0`-`r7`以获得最终数据集项数据。

步骤1中用于初始化寄存器值的常量按以下方式确定：

* 乘数`6364136223846793005`被选择是因为它为线性生成器提供了极好的分布（D. Knuth：计算机程序设计艺术 - 第2卷，也列在[常用LCG参数](https://en.wikipedia.org/wiki/Linear_congruential_generator#Parameters_in_common_use)中）
* 用于初始化寄存器`r1`-`r7`的XOR常量通过计算ASCII值`"RandomX SuperScalarHash initialize"`的`Hash512`并取字节8-63作为7个小端无符号64位整数来确定。此外，`r1`的常量增加了<code>2<sup>33</sup>+700</code>，`r3`的常量增加了<code>2<sup>14</sup></code>（这些更改对于确保所有寄存器对于所有`itemNumber`值都有唯一初始值是必要的）。
